Visual Studio Anotações:

Indice:



Notas importantes:

- Forms/Formas são Classes!
- Estudar Sobrecarga de métodos e Polimorfismo.
- Propriedades Auto-Implementadas vs Métodos Construtores: Os metodos construtores são necessários



Delegates: Um delegate é um tipo de referência que pode ser usado para encapsular um metodo nomeado ou anonimo. São similar em função aos pointers de C++; porém, são type-safe e seguros. São a base dos Eventos (ver abaixo). Pode ser instanciado associando-o com um metodo nomeado ou anonimo. Deve ser instanciado com um metodo ou expressão lamba (???) que tem um tipo compativo de retorno e parametros de input.

	https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/delegate


Eventos/events: Em termo geral, um evento é algo especial que vai acontecer. Em termos de C Sharp, são ações de usuário, como apertar botões, clicks, movimento de mouse, a ocorrência de notificações geradas pelo sistema, etc. Aplicações precisam responder á eventos quando eles ocorrem. Por exemplo, interrupts. Eventos são usados para comunicação inter-processo. Um evento é nada mais que um delegado encapsulado.
	Um evento é compost por:

	- editor/publisher: É a classe que envia (ou aciona) o evento. Determina quando o evento é realizado. É um objeto que contem a definição do evento e do delegado. Invoca o evento e este é notificado para os outros objetos.	
	- assinantes/subscribers: São as classes que recebem (ou manipulam/handle) o evento. Is assinantes determinam a ação que é tomada em resposta ao evento.
	- handlers/manipuladores:
	- notificação/notification:

	https://www.tutorialspoint.com/csharp/csharp_events.htm
	https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/events/
	http://www.tutorialsteacher.com/csharp/csharp-event

	Eventos tem as seguintes propriedades:
	* Um evento pode ter multiplos assinantes. Um assinante pode manipular/handle multiplos eventos de multiplos editores/publishers.
	* Eventos sem assinantes nunca são erigidos.
	* Eventos são tipicamente usados para assinalar ações de usuário como clicks de botão ou seleções de menu em interfaces gráficas de usuário.
	* Quando um evento tem multiplos assinantes, os manipuladores de evento são invocados sincronicamente quando o evento é levantado. É possivel, porém, invocar eventos assincronos. Ver aqui: https://docs.microsoft.com/pt-br/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously
	* Na biblioteca .NET Framework, eventos são baseados no delegado/delegate EventHandler e a classe base EventArgs.



	Lista de eventos:

	FormClosed: Carrega um evento ao fechar o Formulário.
		ex:

	btn_click	


		


Toolbox:

	Common Controls/Controles Comuns:

		CheckBox: Um componente onde existem várias opções e é permitido marcar uma ou mais delas.


		Label: Provê uma descrição run-time ou texto descriptivo para um control


		NumericUpDown: Exibe um único valor numérico que o usuário pode acrescentar e decrementar clicando nos botões acima e abaixo do controle.

			.value: Valor atual do controle numérico acima-abaixo. Por exemplo, colocar 5 significa que começa como cinco no padrão.

			.Maximum: Indica o valor máximo para o controle numérico acima-abaixo.

		PictureBox: 

			 Propriedade Sizemode: Define a maneira que a imagem será exibida no formulário. Tem três opções:

			 	- Normal: A imagem é exibida em seu tamanho normal e sempre é posicionada a partir do canto superior do componente; caso a imagem seja maior que Picturebox, ela será cortada.

			 	- StretchImage: A imagem é ajustada automaticamente ao tamanho do PictureBox

			 	- Autosize: o PictureBox altera seu tamanho automaticamente, para se ajustar ao tamanho da imagem.


		ComboBox: Exibe uma caixa de texto editável com uma lista suspensa de valores permitidos. 
			 
			 	Propriedades:

			 		.AutoCompleteCustomSource: 

			 		.AutoCompleteMode:

			 		.AutoCompleteSource:	

				 	.Items: Itens na caixa de combinação. São os valores permitidos da lista suspensa. 

				 	.Locked: Especifica se é possivel editar o dado do controle na visão do formulário. Booleana Ler/Gravar. Configuração padrão é True/Verdadeiro, que permite editar, adicionar e deletar dados.

				 	.DropDownStyle: Permite apenas que items sejam selecionados.

						- Dropdown: O valor padrão. indica que a porção do texto é editável e assim o usuário pode digitar qualquer valor na área de Texto da Combobox.

				 	 	- DropDownList: Permite que items sejam apenas selecionados em uma lista. Também muda a aparência.

				 	 	- Simple: Se o valor for definido como Simple a porção do Texto poderá ser editada e os valores da lista ficaram sempre visíveis.

				 	 .DropDownHeight: Altura da área de dropdown.
				 	 
				 	 .DropDownWidth: Largura da área de dropdown.	


				 	 Link úteis: 
				 	 http://www.macoratti.net/11/01/c_cbo1.htm	
				 	 https://www.dotnetperls.com/combobox
				 	 https://stackoverflow.com/questions/11167861/combo-box-if-statement
					 https://stackoverflow.com/questions/10539528/what-does-each-combobox-selected-return (o que ComboBoxes retornam)

		Textbox: Cria uma caixa de texto que permite ao usuário inserir texto, e provêm edição multi-linha e mascaração de texto de senha.

			Propriedades:

				.Borderstyle: Altera o estilo da borda ao redor da Textbox.

				.ReadOnly: Torna a TextBox somente leitura, ou seja, não podemos escrever nada nela. Parâmetros: True/False.

				.Multiline: Controla se o texto no controle de edição pode ser extendido em mais de uma linha. Em outra palavras, ele permite que uma textbox ou um controle semelhante pode usar mais de uma linha. Tanto que ele abre a possibilidade de expandir o tamanho de um Textbox na vertical.
				True: Permite que insiramos várias linhas. False: Apenas uma linha.	 	 	


Containers:

	Panel: Auxillia na composição do formulário, possibilitando agrupar vários componentes dentro dele, deixando o trabalho com um aspecto mais organizado.	Por exemplo, se eu deixar um panel com vários botões invisiveis, tanto o panel como os botões dentro dele desaparecerão.	


Propriedades:


	.AppendText: Exibe todo o conteúdo desejado simultaneamente.

	Background Color: Altera cor do pano de fundo do aplicativo.

		Nota: A cor bacaninha cinza do Windows é a cor Control, no System.


	Border Style: Indica se o painel deve ter uma borda.
	
		Fixed Single: Impede o redimensionamento da border durante execução do programa, deixando-a fixa.	


	Font: Altera a fonte de texto de formulários e tal, tipo de fonte, tamanho, etc.	


	FormBorderStyle: Indica a aparência e ação  da borda e da barra de titulo da Forma.

		FixedSingle: Impede redimensionamento da janela durante a execução do programa, deixando ela fixa.

	Start Position: Determina a posição da forma quando ela aparece/inicia.

		Center Screen: Deixa o formulário centralizado na tela quando estiver em execuão.

	Icon: Altera icone do formulário na janela.			


	MaximizeBox: Determina se a forma tem o botãozinho de maximize box ativo na janela.

	Newline: String que denota nova linha. A mesma coisa que "\r\n" pra plataformas não-Unix, ou simplesmten \n para plataformas Unix.

		Enviroment.Newline: Uma maneira "universal" de declarar Nova Linha, de modo que funciona em qualquer sistema operacional.

	Leituras recomendadas: 
	https://www.dotnetperls.com/newline
	https://docs.microsoft.com/en-us/dotnet/api/system.environment.newline?view=netframework-4.7.2	


	Sizemode: Acessada pelo componente PictureBox, temos acesso á propriedade SizeMode, na qual define a maneira em que a imagem será exibida no formulário. Ela tem as seguintes opções:

		Normal - a imagem é exibida em seu tamanho normal e sempre é posicionada a partir do canto superior do componente; caso a imagem seja maior que a PictureBox, ela será cortada.

		StretchImage - a imagem é ajustada automaticamente ao tamanho do PictureBox.

		AutoSize - o PictureBox altera seu tamannho automaticamente, para se ajustar ao tamanho da imagem.

	Text: Texto exibido no elemento.	



Notas de programação C#:

Componente: Ler esse artigo á seguir - https://msdn.microsoft.com/en-us/library/0b1dk63b.aspx

	OpenFileDialog: Usado para selecionar e localizar arquivos em um computador.
	
	http://www.macoratti.net/10/11/c_opfd1.htm é ótimo pra explicar!

	Propriedades do OpenFileDialog:

		1- InitialDirectory - Representa o diretório a ser exibido quando a janela de diálogo aparecer pela primeira vez.
		Ex: openFileDialog1.InitialDirectory = @"C:\";
		Se a propriedade RestoreDirectory for definida como True a caixa de diálogo restaura o diretório atual antes de ser fechada.
		Ex: openFileDialog1.RestoreDirectory = true;

		2- Title - Usada para definir ou atribuir um título a janela de diálogo: Ex: openFileDialog1.Title = "Localizar Arquivos";

		3- Default Extension - Representa a extensão padrão do arquivo a ser localizado: Ex: openFileDialog1.DefaultExt = "txt";

		4- Filter - Representa o filtro da janela de diálogo que será usado para filtrar o tipo de arquivos a serem 
		carregados durante a localização. O exemplo abaixo exibe somente arquivos com extensão .txt:
		Ex: openFileDialog1.Filter = "txt files (*.txt)|*.txt|All files (*.*)|*.*";

		5- FilterIndex - Representa o indíce do filtro atualmetne selecionado na janela de diálogo: Ex:openFileDialog1.FilterIndex = 2;

		6- ChecFileExists - Indica se a janela de diálogo exibirá um aviso se o usuário especificar um nome de arquivo inexistente;
		Ex: openFileDialog1.CheckFileExists = true;

		7- CheckPathExists - Indica se a janela de diálogo exibirá um aviso se o usuário especificar um caminho inexistente;
		Ex: openFileDialog1.CheckPathExists = true;

		8- FileName - Representa o nome do arquivo selecionado na janela de diálogo. Ex: textBox1.Text = openFileDialog1.FileName;

		9- MultiSelect - Se esta propriedade for definida como True pode-se selecionar mais de um arquivo e FileNames representará todos
		os arquivos selecionados. Neste caso deve-se usar um laço foreach para exibir os arquivos selecionados. 
		     this.openFileDialog1.Multiselect = true; 
		     foreach (String file in openFileDialog1.FileNames) 
		     {     MessageBox.Show(file);  }

		10- ReadyOnlyChecked - Indica se a caixa de verificação estará selecionada: Ex: openFileDialog1.ReadOnlyChecked = true;

		11- ShowReadyOnly - Indica se a caiaxa de verificação read-only estará disponível ou não. Ex: openFileDialog1.ReadOnlyChecked = true;

Tipos:

		string: String de caracteres.
		void: Vazio.

Classes: Estrutura que define um determinado conjunto de objetos que possuem características em comum. Uma classe descreve as ações que podem ser realizadas por seus objetos e quais informações eles poderão armazenar. Conceitos importantes:

	Classe Abstrata: Uma classe herdada por outra classe, onde é posteriormente implementada e instânciada. Ela não pode ser instanciada, apenas herdada. Ela é conceitual, define funcionalidades para que as classes que herdarem-na possam implementar. Seria a "planta da casa", enquanto que a classe concreta é a cada em si. Ela pode ter métodos concretos ou abstratos. 
	
		Se forem concretos os metodos, eles podem conter implementação dentro da classe abstrata e ao herda-la não é necessário a utilização deles. Porém, se elaborarmos métodos abstratos, estamos apenas dizendo que este existirá e teremos que implementa-lo na classe que herdar a classe abstrata.

		Metodos Abstratos:

	String: A classe string definida na Biblioteca .NET representa texto como uma série de caracteres Unicode. A classe string provem metodos e propriedades para trabalhar com string. A classe string tem metodos para clonar string, comparar strings, concatenar e copiar strings. Ela também provem métodos para encontrar uma substring numa string, encontrar o index de um caractere ou substring, substituir caracteres, dividr string, aparar string, e adicionar padding á string.
		A classe string também provem métodos para converter os caracteres de uma string para letra maiuscula (uppercase) ou minuscula (lowercase).

	https://www.c-sharpcorner.com/article/string-in-C-Sharp/
	
		Metodos de String:
			- String.Remove: Retorna uma nova string na qual um numero especificado de caracteres da string atual é deletado.
				ex:
			    public string Remove (int startIndex);


			https://docs.microsoft.com/pt-br/dotnet/api/system.string.remove?view=netframework-4.7.2


		Propriedades de String:		


	Encapsulamento: Separação de códigos. Deixamos a variável privada e utilizar metodos para acessa-la, deixando-a mais isolada possivel do usuário. Ou seja, encapsular significa ocultar informações, definindo que cada objeto, contém todos os detalhes de implementação necessários sobre como ele funciona e oculta os detalhes internos sobre como ele executa os serviços.	

	Instância/instance (OOP): Ocorrência concreta de um objeto. Formalmente sinônimo com objeto. Instanciação é a criação de uma Instância.

	Interface: A interface é muito semelhante á uma classe, porém não contem implementação. Não podemos definir campos nela, apenas contém definições de metodos e atributos. Ela também não permite metodos construtores, pois nesses temos instruções usadas para inicializar campos. Para manipulá-la, devemos utilizar a herança. 

	Um exemplo (da apostila) seria um contrato e suas cláusulas. O contrato é a interface e as claus~ulas são os métodos. A classe que herda-a tem que cumprir com o contrato, ou seja, implementar todos os metodos existentes. A interface define as operações que um objeto será obrigado á implementar.

	http://www.macoratti.net/11/11/c_intf1.htm
	https://www.tutorialspoint.com/csharp/csharp_interfaces.htm
	https://www.caelum.com.br/apostila-csharp-orientacao-objetos/interfaces/
	https://pt.stackoverflow.com/questions/107524/como-e-quando-usar-interface

	Herança de Classes: Capacidade de sub-classes de herdarem os objetos de suas classes-pai.:
		https://stackoverflow.com/questions/4245816/how-to-create-a-subclass-in-c


	Propriedades Autoimplementadas: Possibilitam a redução da quantidade de código necessário no momento de inplementar atributos e propriedades à uma classe.

		http://www.linhadecodigo.com.br/artigo/1420/csharp-30-auto-implemented-properties.aspx

		https://www.javatpoint.com/csharp-auto-implemented-properties

		http://www.linhadecodigo.com.br/artigo/1716/csharp-30-novidades-parte-1-propriedades-automaticas-automatic-properties.aspx

		https://pt.stackoverflow.com/questions/15467/m%C3%A9todos-e-propriedades-em-c-vantagens-e-desvantagens

		https://pt.stackoverflow.com/questions/124742/diferen%C3%A7as-no-construtores-usando-propriedade-vs-field

		http://delegadoanonimo.github.io/2015/01/02/algumas-novidades-csharp6/

		Exemplo de programa de console com propriedades AutoImplementadas:
		
		using System;

				namespace PropriedadesAutoImplementadas2
				{
				    public class Movie
				    {
				        public string Titulo { get; set; }

				        public string Genero { get; set; }

					        public override string ToString()
					        {
					            return Titulo + "\t" + Genero;
					        }

				    }



				    class Program
				    {
				        static void Main(string[] args)

				        {

				            Movie m = new Movie();

				            m.Titulo = "Em busca da felicidade";

				            m.Genero = "Drama";

				            Console.WriteLine(m);

				            Console.ReadLine();

				        }

				    }

				}

	MessageBox: Exibe uma janela de mensagem, também conhecida como caixa de dialogo, que exibe uma mensagem ao usuário. Mais info em: https://docs.microsoft.com/pt-br/dotnet/api/system.windows.forms.messagebox?redirectedfrom=MSDN&view=netframework-4.7.2

		E também: https://www.dotnetperls.com/messagebox-show

		A ordem dos argumentos é:
		(string, titulo em string, outros valores, outros valores)

	   Metodos da classe MessageBox::

		MessageBox.Show: Mostra a MessageBox. È um metodo estático, ou seja, não precisamos criar nenhuma outra MessageBox() em lugar algum de nosso código.

		Nota pra si: Pesquisar o que é "Metodo Estático" (Static Method - termos diferentes em outras linguas?)
	 	
	 	.MessageBoxButtons: Mostra botões á serem exibidos na Message Box. 

	 	    MessageBoxButtons[NomeDosBotões]: Colocamos o nome dos botões da DialogBox. Por exemplo, MessageBoxButtons.YesNo, fará a Dialog box com dois botões Yes/No. Podemos adicionar uma variável para o resultado de MessageBox.Show. Por exemplo, podemos testar result1 pra saber qual botão foi apertado.

	 		MessageBoxIcon.Question: Adiciona um icone de pergunta e a opção "cancel" á pergunta feita no código anterior.

	 		MessageBoxDefaultButton.[nome do botão]: Especifica o botão "padrão" do argumento. Por exemplo, podemos colocar Button1 numa pergunta de Sim/Não/Cancelar, e ai o Sim será o botão padrão pré-marcado, pois ele é o primeiro (button1). Por exemplo: .MessageBoxDefaultButton.Button1.

	 		DialogResult: Interrompe a lógica pra testar os resultados dos botões apertados anteriormente no dialogo. Exemplo no qual estamos os três ultimos resultados de apertos de botões:

	 		if (result1 == DialogResult.Yes &&
	   		result2 == DialogResult.Yes &&
	    	result3 == DialogResult.No)
		{
	    	MessageBox.Show("You answered yes, yes and no.");
		}

			MessageBoxOptions.RightAlign: Alinha os botões no dialogo. Nesse comando, alinhamos pela direita. Podemos usar .LeftAlign pra ir alinhar á esquerda.

			MessageBoxIcon.[nome do icone]: Insere um icone na MessageBox. Por exemplo, MessageBoxIcon.Warning vai inserir um icone de aviso no dialogo.





	Application.Run(()): Comando comumente encontrado em program.cs. Faz com que o referido formulário execute primeiro. Exemplo: Application.Run(new FrmMenuPrincipal()); - esse código fará com que o aplicativo inicie uma nova instância do formulário MenuPrincipal.



	PictureBox: Comando que invoca PictureBox pra exibir uma imagem.

		PictureBoxSizeMode.: Especifica como uma certa imagem é posicionada dentro da PictureBox. Seus parâmetros são Normal, StretchImage e AutoSize. É o comando sizemode das propriedades, só que em código. Por exemplo: PictureBoxSizeMode.Normal, faz a imagem ficar no tamanho normal.

			.Load: Carrega um arquivo.

			.Image: Age com uma imagem. Por exemplo, PictureBox.Image = Null, faz com que a imagem da PictureBox seja nula, ou seja, não tem imagem.

			.Show: Abre uma janela imediatamente. Ver mais comentário aqui: https://docs.microsoft.com/pt-br/dotnet/api/system.windows.window.show?redirectedfrom=MSDN&view=netframework-4.7.2#System_Windows_Window_Show

			.Visible = True/False #Torna objetos visiveis (true) ou invisiveis (false). Por exemplo, TextBox1.Visible tornaria uma Textbox invisivel.

			.Hide: Esconde o conteudo.


Control:

	.Enabled: Obtém ou define um valor que indica se o controle pode ou não responder á interação do usuário.

Tipos de data/Data Types pra C#:
	- Bool(ean)
	- Signed Integral, ou Int.
	- Unsigned Integral. uint.
	- Floating point. Float. Double.
	- Char
	- Decimal.

		Os tipos usados pra armazenar números são Float, Double e Decimal.

		Em caso de contas com dinheiro ou finanças, sempre utilize decimal.

		Leituras úteis:
		https://www.programiz.com/csharp-programming/variables-primitive-data-types
		http://www.macoratti.net/12/12/c_num1.htm


	

Métodos: Determina o comportamento dos objetos de uma classe.
	Tipos de Métodos:

		Metodo Abstrato:

		Metodos de Acesso (ou Acessores): Responsáveis pela leitura e gravação de dados. São dois, o Set e o Get.
			Set: Leitura de dados.
			Get: Gravação de dados.



		Metodo Construtor: 
			Responsável por instanciar (criar) e inicializar os atributos de um objeto. Todo metodo construtor deve ser public, não possuir nenhum retorno e ter o mesmo nome da classe.

			https://blogdocodigo.wordpress.com/2015/02/25/c-criando-classes-objetos-metodos-construtores-e-acessores/	
			http://www.guj.com.br/t/construtor-pra-que-realmente-serve/55265/5

			http://dtidigital.com.br/blog/a-nova-e-melhorada-c-conheca-a-csharp6-0/

		Metodo Estático: 
			https://pt.stackoverflow.com/questions/54012/qual-a-fun%C3%A7%C3%A3o-de-um-m%C3%A9todo-est%C3%A1tico

		Parse/Análise Sintática: Uma string, quando é processada por Parse/Análise Sintática, pode ser representada como outro tipo de dado, como int. Por exemplo, a string 100. Ela pode ser representada em um int de 4 bytes.
		Leitura interessante:
		https://www.dotnetperls.com/parse	

		Metodos de Repetição:

			FOR: No laço de repetição FOR, iteramos por uma série de números. Progredimos de um ponto á outro. Geralmente, se usa i como a variável, que começa como o número 0. A maioria dos metodos de coleção em C# são baseados em zero, então o primeiro número do loop é 0. Exemplo simples:

				class Program
			{
		    static void Main()
		    {
		        for (int i = 0; i < 10; i++)
		        {
		            Console.WriteLine(i);
		        }
		    }

		    Valores de saida:
		    0
			1
			2
			3
			4
			5
			6
			7
			8
			9

		    O que está acontecendo aqui? Temos um laço de incremento (ou seja, ele aumenta á cada repetição), o qual persiste em executar até i = 10 (ou algum outro valor configurado). Ao chegar no 10, ele para. 

			Nota: i++ ou i-- é um "interaction statement". Ele ocorre após cada passada da iteração.

			Seu oposto é um laço de decremento, onde á cada repetição do laço, o valor de i diminui. Note que aqui começamos com um 10, e continuamos até 0 chegar.


		    class Program
			{
			    static void Main()
			    {
			        for (int i = 10 - 1; i >= 0; i--)
			        {
			            Console.WriteLine(i);
			        }
			    }
			}

			Output

			9
			8
			7
			6
			5
			4
			3
			2
			1
			0

			Aqui ocorre o oposto: Á cada repetição do laço, o valor de i diminui, até chegar á 0.



			Passo de Iteração: O terceiro parâmetro do laço de repetição FOR é o passo. Ele pode mudar a variável i ou qualquer outra por qualquer quantidade - a constante nem é necessária.
				ex: Adicionamos dois após cada passagem pelo laço de repetição.

			class Program
			{
			    static void Main()
			    {
			        for (int i = 0; i < 10; i += 2)
			        {
			            Console.WriteLine(i);
			        }
			    }
			}

			Output

			0
			2
			4
			6
			8	


			Passo de decrementação: O mesmo do acima, porém para trás.

			class Program
			{
			    static void Main()
			    {
			        for (int i = 10 - 1; i >= 0; i -= 2)
			        {
			            Console.WriteLine(i);
			        }
			    }
			}

			Output

			9
			7
			5
			3
			1


			Expressão, quantidade máxima: Expressões completas e até mesmo chamada de Métodos, pode ser usados como condições de um Laço de Repetição For. ex:

			class Program
			{
			    static void Main()
			    {
			        for (int i = 0; i < (20 / 2); i += 2)
			        {
			            Console.WriteLine(i);
			        }
			    }
			}

			Output

			0
			2
			4
			6
			8

			O que aconteceu aqui:



			Leitura recomendada: https://www.dotnetperls.com/for

		

		ToString: Metodo virtual. Retorna uma representação de string. É um metodo que retorna uma cadeia de caracteres desse objeto.
			https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/classes-and-structs/how-to-override-the-tostring-method

Modificador de Acesso: Palavras-chave usadas para especificar a acessibilidade declarada de um membro ou de um tipo. Existem quatro modificadores de acesso:

	https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/access-modifiers


	1. public:

	2. Protected

	3. internal:

	https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/internal

	4. private:


	Existem seis niveis de acessibilidade que podem ser especificados usando os modificadores de acesso:
	

    public: o acesso não é restrito.

    protected: o acesso é limitado à classe que os contém ou aos tipos derivados da classe que os contém.

    internal: o acesso é limitado ao assembly atual.

    protected internal: o acesso é limitado ao assembly atual ou aos tipos derivados da classe que os contém.

    private: o acesso é limitado ao tipo recipiente.

    private protected: o acesso é limitado à classe que o contém ou a tipos derivados da classe que o contém no assembly atual.

Instruções: As ações que um programa toma são expressadas em instruções. Ações comuns incluem declarar variáveis, escolher valores, chamar métodos, fazer laços por coleções, e indo de um bloco até o outro do código, dependendo da instrução. A ordem na qual as instruções são executadas em um programa é chamada de flxuo de controle ou fluxo de execução. O fluxo de controle pode variar cada vez que o programa é executado, dependendo de como o programa reage ao input que recebe no tempo de inicialização.

	Uma instrução pode consistir de uma linha de código que termina em ponto e virgula (;), ou uma série de afirmações de uma linha em um bloco. Um bloco de instrução é enclausurado por chaves { } e pode conter blocos aninhados. 

	https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements

	Tipos de Instrução:

		Instrução de Declaração: Introduz uma nova variável ou constante. Uma declaração variável pode opcionalmente atribuir um valor á variável. Em uma declaração constante, a atribuição é necessária.

		Instrução de Expressão: Instruções de Expressão que calcula um valor devem guardar um valor em uma variável.

		Instrução de Seleção: Instruções de Seleção permitem ramificar para seções diferentes do código, dependendo de uma ou mais condições especificadas. 

			- if:

			- else:

			- switch: É uma instrução de seleção que escolhe uma única seção switch para ser executada de uma lista de candidatas com base em uma correspondência  de padrão com a expressão de correspondência. . A instrução switch é comumente usada como uma alternativa para um construto if-else se uma única expressão é testada contra três ou mais condições.

			https://www.dotnetperls.com/switch
			https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/switch
			https://www.c-sharpcorner.com/article/string-in-C-Sharp/

			- case:

		Instrução de Iteração: Permitem fazer um laço por coleções como arrays, ou performar o mesmo conjunto de instruções até que uma condição especifica seja encontrada.

			- do:

			- for:

			- foreach:

			- while:


		Instrução de Salto: Instruções de Salto transferem controle para outra seção do código.

			- break:

			- continue:

			- default:

			- yield:


		Instrução de Manipulação de Excessão: Instruções de manipulação de excessão permitem graciosamente recuperar-se de condições excepcionais em tempo de execução.

			- throw:

			- try-catch:

			- try-finally:

			- try-catch-finally:

		Verificado e não-verificado(Checked e unchecked): Permitem especificar se operações numéricas são permitidas causar overflow quem o resultado é guardado numa variável que é muito pequena para guardar o valor resultante.

			- checked:

			- unchecked:

		A instrução await: Se você marcar o método com o modificador async, você pode usar o operador await no método. Quando controle chega numa expressão await no metodo async, control retorna o chamador, e progresso no método é suspenso até que a tarefa esperada complete. Quando a tarefa está completa, execução pode resumir no método.

		A instrução yield return: Um iterador performa uma iteração customizada sobre uma coleção, como uma lista ou array. Um iterador usa a instrução yield return para retornar cada elemento, um de cada vez. Quando a instrução yield return é alcançada, a localização atual no código é lembrada. Execução é reiniciada dessa localização quando o iterador é chamado da próxima vez.

		A instrução fixed: Instrução fixed previne o coletor de lixo de relocar uma variável movivel.

			- fixed:

		A instrução lock: Permite limitar acesso á blocos de código para uma thread de cada vez.

			- lock

		Instrução labelada: Você pode dar uma label á instrução e usa a palavra-chave goto para pular para a instrução labelada.

		A instrução vazia(empty): Consiste de um unico ponto e virgula (;). Ela não faz nada e pode ser usado em lugares onde uma instrução é necessária mas nenhuma ação precisa ser feita.


	return: Finaliza a execução do método em que aparece e retorna o controle para o método de chamada. Pode retornar um valor opcional. Se o metodo for do tipo void, a instrução return pode ser omitida.

	https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/return

	

Palavras-Chave:

	Override: Palavra-chave que significa que iremos sobrescrever um método/evento/propriedade. Todos que possuirem a keyword "virtual" são passiveis de override.	

		https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/override

	base: Palavra-chave usada em construtores (em inicializadores de construtor). Um construtor de classe derivada é necessário para chamnar o construtor de sua classe base.

		https://www.dotnetperls.com/base

Programação Orientada a Objetos (OOP):
	https://ericlemes.com/2009/03/03/dotnet-oop/	

Sequências e caracteres de escape: Combinação de caracteres, que consiste numa barra invertida (\), seguida por uma letra ou digitos que realizam uma determinada ação, como por exemplo: pular uma linha, inserir espaço, uma guia vertical, entre outras opções. Ver: https://msdn.microsoft.com/pt-br/library/h21280bw.aspx

	Caracteres:
		\a	Campainha (alerta)
		\b	Backspace
		\f	Avanço de página
		\n	Nova linha. Quebra linha de uma string
		\r	Retorno de carro
		\t	Tabulação horizontal
		\v	Tabulação vertical
		\'	Aspas simples
		\"	Aspas duplas
		\\	Barra invertida
		\?	Ponto de interrogação literal
		\ ooo	Caractere ASCII em notação octal
		\x hhhh	Caractere Unicode em notação hexadecimal, se esta sequência de escape é usada em uma constante de caractere largo ou uma literal de cadeia de caracteres Unicode.
		Por exemplo, WCHAR f = L'\x4e00' ou WCHAR b[] = L"The Chinese character for one is \x4e00".

Sobrecarga de Metodos: https://www.devmedia.com.br/sobrecarga-de-metodos/4190

Permite a redefinição de métodos usados no C# para utilização com tipos definidos pelo usuário. É um outro metodo, por assim dizer, de chamar um método. O C# permite que nós tenhamos vários métodos com o mesmo nome dentro de uma mesma classe, mas desde que estes métodos tenham diferentes conjuntos de parâmetros, sejam eles números, simplesmente a ordem dos parâmetros ou então tipos diferentes. O compilador trata um método sobrecarregado, quando este método for chamado, da seguinte maneira: primeiramente o compilador selecionará o método correto examinando o numero, em seguida os tipos e por fim a ordem dos argumentos da chamada.

